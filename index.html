<html>
<head>
<title>Support Vector Machine in Javascript</title>
<link type="text/css" href="lib/jqueryui/css/ui-lightness/jquery-ui-1.8.21.custom.css" rel="Stylesheet"/>
<script type="text/javascript" src="lib/jqueryui/js/jquery-1.7.2.min.js"></script>
<script type="text/javascript" src="lib/jqueryui/js/jquery-ui-1.8.21.custom.min.js"></script>
<script src="lib/underscore/underscore.js"></script>
<script src="lib/sge/sge.js"></script>
<script src="lib/svm/SVM.js"></script>
<script src="lib/svm/SVMModel.js"></script>
<script type="text/javascript">

var N = 10; //number of data points
var data = new Array(N);
var labels = new Array(N);
var wb; // weights and offset structure
var ss = 50.0; // scaling factor for drawing
var svm = new SVM();
var trainstats;
var dirty = true;
var kernelid = 1;
var rbfKernelSigma = 0.5;
var svmC = 1.0;
var SimpleGameEngine;

function init()
{
    initSVM();

    SimpleGameEngine = new SGE({
        draw: draw,
        update: update,
        mouseClick: mouseClick,
        keyDown:keyDown,
        keyUp:keyUp,
        canvas: document.getElementById('SGECanvas'),
        height: 500,
        width: 500
    });


}

function initSVM()
{

    data[0] = [0.2487428  , 0.6 ];
    data[1] = [0.3792000, 0.85];
    data[2] = [0.1253 , -0.0376   ];
    data[3] = [0.2877 , 0.3273  ];
    data[4] = [0.237 , 0.46 ];
    data[4] = [0.3252 , 0.71 ];

    data[5] = [1.8133 , 2.1139  ];
    data[6] = [2.7258 , 3.0668  ];
    data[7] = [1.4117 , 2.0593  ];
    data[8] = [4.1832 , 1.9044  ];
    data[9] = [1.8636 , 1.1677  ];

    labels[0] = 1;
    labels[1] = 1;
    labels[2] = 1;
    labels[3] = 1;
    labels[4] = 1;
    labels[5] = -1;
    labels[6] = -1;
    labels[7] = -1;
    labels[8] = -1;
    labels[9] = -1;


    retrainSVM();
}

function retrainSVM()
{
    console.log('retrainSVM');

    svm.setOptions({
        kernelType: SVM.kernelPoly,
        rbfSigma: rbfKernelSigma,
        C: svmC
    });
    trainstats = svm.train(data, labels);

    console.log(trainstats);

    dirty = true; // to redraw screen
}

function update()
{
    //draw.call(this);
}

function draw()
{
    if(!dirty)
    {
        return;
    }

    this.ctx.clearRect(0, 0, this.width, this.height);

    // draw decisions in the grid
    var density = 4.0;
    for (var x = 0.0; x <= this.width; x += density)
    {
        for (var y = 0.0; y <= this.height; y += density)
        {
            var dec = svm.marginOne([(x - this.width / 2) / ss, (y - this.height / 2) / ss]);
            if (dec > 0)
            {
                this.ctx.fillStyle = 'rgb(150,250,150)';
            }
            else
            {
                this.ctx.fillStyle = 'rgb(250,150,150)';
            }
            this.ctx.fillRect(x - density / 2 - 1, y - density - 1, density + 2, density + 2);
        }
    }

    // draw axes
    this.ctx.beginPath();
    this.ctx.strokeStyle = 'rgb(50,50,50)';
    this.ctx.lineWidth = 1;
    this.ctx.moveTo(0, this.height / 2);
    this.ctx.lineTo(this.width, this.height / 2);
    this.ctx.moveTo(this.width / 2, 0);
    this.ctx.lineTo(this.width / 2, this.height);
    this.ctx.stroke();

    // draw datapoints. Draw support vectors larger
    this.ctx.strokeStyle = 'rgb(0,0,0)';

    for (var i = 0; i < N; i++)
    {

        if (labels[i] == 1)
        {
            this.ctx.fillStyle = 'rgb(100,200,100)';
        }
        else
        {
            this.ctx.fillStyle = 'rgb(200,100,100)';
        }

        if (svm.alpha[i] > 1e-2)
        {
            this.ctx.lineWidth = 3;
        } // distinguish support vectors
        else
        {
            this.ctx.lineWidth = 1;
        }

        this.drawCircle(data[i][0] * ss + this.width / 2, data[i][1] * ss + this.height / 2, Math.floor(3 + svm.alpha[i] * 5.0 / svmC));
    }

    // if linear kernel, draw decision boundary and margin lines
    if (svm.options.kernelType == SVM.kernelLinear)
    {
        var xs = [-5, 5];
        var ys = [0, 0];
        ys[0] = (-svm.bias - svm.weights[0] * xs[0]) / svm.weights[1];
        ys[1] = (-svm.bias - svm.weights[0] * xs[1]) / svm.weights[1];

        this.ctx.fillStyle = 'rgb(0,0,0)';
        this.ctx.lineWidth = 1;
        this.ctx.beginPath();

        // wx+b=0 line
        this.ctx.moveTo(xs[0] * ss + this.width / 2, ys[0] * ss + this.height / 2);
        this.ctx.lineTo(xs[1] * ss + this.width / 2, ys[1] * ss + this.height / 2);

        // wx+b=1 line
        this.ctx.moveTo(xs[0] * ss + this.width / 2, (ys[0] - 1.0 / svm.weights[1]) * ss + this.height / 2);
        this.ctx.lineTo(xs[1] * ss + this.width / 2, (ys[1] - 1.0 / svm.weights[1]) * ss + this.height / 2);

        // wx+b=-1 line
        this.ctx.moveTo(xs[0] * ss + this.width / 2, (ys[0] + 1.0 / svm.weights[1]) * ss + this.height / 2);
        this.ctx.lineTo(xs[1] * ss + this.width / 2, (ys[1] + 1.0 / svm.weights[1]) * ss + this.height / 2);
        this.ctx.stroke();

        // draw margin lines for support vectors. The sum of the lengths of these
        // lines, scaled by C is essentially the total hinge loss.
        for (var i = 0; i < N; i++)
        {
            if (svm.alpha[i] < 1e-2)
            {
                continue;
            }
            if (labels[i] == 1)
            {
                ys[0] = (1 - svm.bias - svm.weights[0] * xs[0]) / svm.weights[1];
                ys[1] = (1 - svm.bias - svm.weights[0] * xs[1]) / svm.weights[1];
            }
            else
            {
                ys[0] = (-1 - svm.bias - svm.weights[0] * xs[0]) / svm.weights[1];
                ys[1] = (-1 - svm.bias - svm.weights[0] * xs[1]) / svm.weights[1];
            }
            var u = (data[i][0] - xs[0]) * (xs[1] - xs[0]) + (data[i][1] - ys[0]) * (ys[1] - ys[0]);
            u = u / ((xs[0] - xs[1]) * (xs[0] - xs[1]) + (ys[0] - ys[1]) * (ys[0] - ys[1]));
            var xi = xs[0] + u * (xs[1] - xs[0]);
            var yi = ys[0] + u * (ys[1] - ys[0]);
            this.ctx.moveTo(data[i][0] * ss + this.width / 2, data[i][1] * ss + this.height / 2);
            this.ctx.lineTo(xi * ss + this.width / 2, yi * ss + this.height / 2);
        }
        this.ctx.stroke();
    }

    this.ctx.fillStyle = 'rgb(0,0,0)';
    this.ctx.fillText("Converged in " + trainstats.iterations + " iterations.", 10, this.height - 30);
    var numsupp = 0;
    for (var i = 0; i < N; i++)
    {
        if (svm.alpha[i] > 1e-5)
        {
            numsupp++;
        }
    }

    this.ctx.fillText("Number of support vectors: " + numsupp + " / " + N, 10, this.height - 50);

    if (svm.options.kernelType == SVM.kernelRBF)
    {
        this.ctx.fillText("Using Rbf kernel with sigma = " + rbfKernelSigma.toPrecision(2), 10, this.height - 70);
    }
    else if (svm.options.kernelType == SVM.kernelLinear)
    {
        this.ctx.fillText("Using Linear kernel", 10, this.height - 70);
    }
    else if (svm.options.kernelType == SVM.kernelPoly)
    {
        this.ctx.fillText("Using Poly kernel", 10, this.height - 70);
    }

    this.ctx.fillText("C = " + svmC.toPrecision(2), 10, this.height - 90);

    dirty = false;
}

function mouseClick(x, y, shiftPressed)
{
    // add datapoint at location of click
    data[N] = [(x - this.width / 2) / ss, (y - this.height / 2) / ss];
    labels[N] = shiftPressed ? 1 : -1;
    N += 1;

    // retrain the svm
    retrainSVM();
}

function keyUp(key)
{

    if (key == 82)
    { // 'r'

        // reset to original data and retrain
        data = data.splice(0, 10);
        labels = labels.splice(0, 10);
        N = 10;
        retrainSVM();
    }
    if (key == 75)
    { // 'k'
        // toggle between kernels: rbf or linear
        kernelid = 1 - kernelid; // toggle 1 and 0
        retrainSVM();
    }
}
function keyDown(key)
{
}


// UI stuff
function refreshC(event, ui)
{
    var logC = ui.value;
    svmC = Math.pow(10, logC);
    $("#creport").text("C = " + svmC.toPrecision(2));
    retrainSVM();
}

function refreshSig(event, ui)
{
    var logSig = ui.value;
    rbfKernelSigma = Math.pow(10, logSig);
    $("#sigreport").text("RBF Kernel sigma = " + rbfKernelSigma.toPrecision(2));
    if (kernelid == 1)
    {
        retrainSVM();
    }
}

$(function ()
{
    // for C parameter
    $("#slider1").slider({
        orientation: "horizontal",
        slide: refreshC,
        max: 2.0,
        min: -2.0,
        step: 0.1,
        value: 0.0
    });

    // for rbf kernel sigma
    $("#slider2").slider({
        orientation: "horizontal",
        slide: refreshSig,
        max: 2.0,
        min: -2.0,
        step: 0.1,
        value: 0.0
    });
});
</script>

<style type="text/css">
    canvas {
        border: 1px solid #555;
        margin-top: 10px;
    }

    body {
        text-align: center;
        font-family: Verdana, Helvetica, sans-serif;
        font-size: 12px;
        padding: 0;
        margin: 0;
    }

    h1 {
        font-size: 16px;
    }

    p {
        padding-top: 0;
        padding-bottom: 0;
    }

    .optsdiv {

        padding-top:20px;
        width: 500px;
        margin-left: auto;
        margin-right: auto;
    }
</style>

</head>

<body onLoad="init();">

    <h1>Support Vector Machine in Javascript</h1>


<canvas id="SGECanvas" width="500" height="500">Browser not supported for Canvas. Get a real browser.</canvas>
<div class="optsdiv">
    <div style="width:230px; float: left; margin-left: 10px;">
        <div id="slider1"></div>
        <br/><span id="creport">C = 1.0</span></div>
    <div style="width:230px; float: right; margin-right: 10px;">
        <div id="slider2"></div>
        <br/><span id="sigreport">RBF Kernel sigma = 1.0</span></div>
</div>


</body>
</html>
